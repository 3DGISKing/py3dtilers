<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.Common API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.Common</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .kd_tree import kd_tree
from .feature import Feature, FeatureList
from .tree_with_children_and_parent import TreeWithChildrenAndParent
from .group import Groups
from .polygon_extrusion import ExtrudedPolygon
from .geometry_node import GeometryNode
from .geometry_tree import GeometryTree
from .lod_node import Lod1Node, LoaNode
from .lod_tree import LodTree
from .obj_writer import ObjWriter
from .tileset_creation import FromGeometryTreeToTileset
from .tiler import Tiler

__all__ = [&#39;kd_tree&#39;,
           &#39;Feature&#39;,
           &#39;FeatureList&#39;,
           &#39;TreeWithChildrenAndParent&#39;,
           &#39;Groups&#39;,
           &#39;ExtrudedPolygon&#39;,
           &#39;GeometryNode&#39;,
           &#39;GeometryTree&#39;,
           &#39;Lod1Node&#39;,
           &#39;LoaNode&#39;,
           &#39;LodTree&#39;,
           &#39;ObjWriter&#39;,
           &#39;Tiler&#39;,
           &#39;FromGeometryTreeToTileset&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="py3dtilers.Common.feature" href="feature.html">py3dtilers.Common.feature</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.geometry_node" href="geometry_node.html">py3dtilers.Common.geometry_node</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.geometry_tree" href="geometry_tree.html">py3dtilers.Common.geometry_tree</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.group" href="group.html">py3dtilers.Common.group</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.lod_node" href="lod_node.html">py3dtilers.Common.lod_node</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.lod_tree" href="lod_tree.html">py3dtilers.Common.lod_tree</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.obj_writer" href="obj_writer.html">py3dtilers.Common.obj_writer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.polygon_extrusion" href="polygon_extrusion.html">py3dtilers.Common.polygon_extrusion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.tiler" href="tiler.html">py3dtilers.Common.tiler</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.tileset_creation" href="tileset_creation.html">py3dtilers.Common.tileset_creation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="py3dtilers.Common.tree_with_children_and_parent" href="tree_with_children_and_parent.html">py3dtilers.Common.tree_with_children_and_parent</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="py3dtilers.Common.kd_tree"><code class="name flex">
<span>def <span class="ident">kd_tree</span></span>(<span>feature_list, maxNumObjects, depth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Distribute the features into FeatureList.
The objects are distributed by their centroid.
:param objects: the features to distribute
:param maxNumObjects: the max number of objects in each new group
:param depth: the depth of the recursion</p>
<p>:return: a list of FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kd_tree(feature_list, maxNumObjects, depth=0):
    &#34;&#34;&#34;
    Distribute the features into FeatureList.
    The objects are distributed by their centroid.
    :param objects: the features to distribute
    :param maxNumObjects: the max number of objects in each new group
    :param depth: the depth of the recursion

    :return: a list of FeatureList
    &#34;&#34;&#34;
    # objects should herited from feature_list and
    # dispose of a method get_centroid()
    if (not isinstance(feature_list, FeatureList)):
        return None

    derived = feature_list.__class__

    # The module argument of 2 (in the next line) hard-wires the fact that
    # this kd_tree is in fact a 2D_tree.
    axis = depth % 2

    # Within the sorting criteria point[1] refers to the centroid of the
    # bounding boxes of the city objects. And thus, depending on the value of
    # axis, we alternatively sort on the X or Y coordinate of those centroids:

    feature_list.objects = sorted(feature_list,
                                  key=lambda obj: obj.get_centroid()[axis])
    median = len(feature_list) // 2
    lObjects = feature_list[:median]
    rObjects = feature_list[median:]
    pre_tiles = derived()
    if len(lObjects) &gt; maxNumObjects:
        pre_tiles.extend(kd_tree(lObjects, maxNumObjects, depth + 1))
        pre_tiles.extend(kd_tree(rObjects, maxNumObjects, depth + 1))
    else:
        if len(lObjects) &gt; 0:
            pre_tiles.append(lObjects)
        if len(rObjects) &gt; 0:
            pre_tiles.append(rObjects)
    return pre_tiles</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.Common.ExtrudedPolygon"><code class="flex name class">
<span>class <span class="ident">ExtrudedPolygon</span></span>
<span>(</span><span>feature, override_points=False, polygon=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a 3D extrusion of the footprint of a Feature
:param feature: an instance of Feature containing triangles
:param override_points: when true, the polygon extruded won't be the footprint
but another polygon
:param polygon: the polygon that will be extruded instead of the footprint (when overriding points)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtrudedPolygon():
    def __init__(self, feature, override_points=False, polygon=None):
        &#34;&#34;&#34;
        Creates a 3D extrusion of the footprint of a Feature
        :param feature: an instance of Feature containing triangles
        :param override_points: when true, the polygon extruded won&#39;t be the footprint
        but another polygon
        :param polygon: the polygon that will be extruded instead of the footprint (when overriding points)
        &#34;&#34;&#34;
        geom_triangles = feature.geom.triangles
        points = list()
        minZ = np.Inf
        average_maxZ = 0

        # Compute the footprint of the geometry
        for triangles in geom_triangles:
            maxZ = np.NINF
            for triangle in triangles:
                for point in triangle:
                    if len(point) &gt;= 3:
                        points.append([point[0], point[1]])
                        if point[2] &lt; minZ:
                            minZ = point[2]
                        if point[2] &gt; maxZ:
                            maxZ = point[2]
            average_maxZ += maxZ
        average_maxZ /= len(geom_triangles)
        if override_points:
            points = polygon
        else:
            hull = alphashape(points, 0.)
            points = hull.exterior.coords[:-1]

        self.feature = feature
        self.points = points
        self.min_height = minZ
        self.max_height = average_maxZ

        self.extrude_footprint()

    def get_extruded_object(self):
        return self.extruded_object

    def extrude_footprint(self):
        coordinates = self.points
        length = len(coordinates)
        vertices = [None] * (2 * length)
        minZ = self.min_height
        maxZ = self.max_height

        for i, coord in enumerate(coordinates):
            vertices[i] = np.array([coord[0], coord[1], minZ], dtype=np.float32)
            vertices[i + length] = np.array([coord[0], coord[1], maxZ], dtype=np.float32)

        # Contains the triangles vertices. Used to create 3D tiles
        triangles = list()

        # Triangulate the feature footprint
        poly_triangles = triangulate(coordinates)

        # Create upper face triangles
        for tri in poly_triangles:
            upper_tri = [np.array([coord[0], coord[1], maxZ], dtype=np.float32) for coord in tri]
            triangles.append(upper_tri)

        # Create side triangles
        for i in range(0, length):
            triangles.append([vertices[i], vertices[length + i], vertices[length + ((i + 1) % length)]])
            triangles.append([vertices[i], vertices[length + ((i + 1) % length)], vertices[((i + 1) % length)]])

        extruded_object = Feature(str(self.feature.get_id()) + &#34;_extrude&#34;)
        extruded_object.geom.triangles.append(triangles)
        extruded_object.set_box()
        self.extruded_object = extruded_object</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.ExtrudedPolygon.extrude_footprint"><code class="name flex">
<span>def <span class="ident">extrude_footprint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_footprint(self):
    coordinates = self.points
    length = len(coordinates)
    vertices = [None] * (2 * length)
    minZ = self.min_height
    maxZ = self.max_height

    for i, coord in enumerate(coordinates):
        vertices[i] = np.array([coord[0], coord[1], minZ], dtype=np.float32)
        vertices[i + length] = np.array([coord[0], coord[1], maxZ], dtype=np.float32)

    # Contains the triangles vertices. Used to create 3D tiles
    triangles = list()

    # Triangulate the feature footprint
    poly_triangles = triangulate(coordinates)

    # Create upper face triangles
    for tri in poly_triangles:
        upper_tri = [np.array([coord[0], coord[1], maxZ], dtype=np.float32) for coord in tri]
        triangles.append(upper_tri)

    # Create side triangles
    for i in range(0, length):
        triangles.append([vertices[i], vertices[length + i], vertices[length + ((i + 1) % length)]])
        triangles.append([vertices[i], vertices[length + ((i + 1) % length)], vertices[((i + 1) % length)]])

    extruded_object = Feature(str(self.feature.get_id()) + &#34;_extrude&#34;)
    extruded_object.geom.triangles.append(triangles)
    extruded_object.set_box()
    self.extruded_object = extruded_object</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ExtrudedPolygon.get_extruded_object"><code class="name flex">
<span>def <span class="ident">get_extruded_object</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extruded_object(self):
    return self.extruded_object</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.Feature"><code class="flex name class">
<span>class <span class="ident">Feature</span></span>
<span>(</span><span>id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class of all object that need to be tiled, in order to be
used with the corresponding tiler.</p>
<p>:param id: given identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feature(object):
    &#34;&#34;&#34;
    The base class of all object that need to be tiled, in order to be
    used with the corresponding tiler.
    &#34;&#34;&#34;

    def __init__(self, id=None):
        &#34;&#34;&#34;
        :param id: given identifier
        &#34;&#34;&#34;

        self.geom = TriangleSoup()

        # Optional application specific data to be added to the batch table for this object
        self.batchtable_data = None

        # A Bounding Volume Box object
        self.box = None

        # The centroid of the box
        self.centroid = np.array([0, 0, 0])

        self.texture = None

        self.material_index = 0

        self.set_id(id)

    def set_id(self, id):
        &#34;&#34;&#34;
        Set the id of this feature.
        :param id: an id
        &#34;&#34;&#34;
        self.id = id

    def get_id(self):
        &#34;&#34;&#34;
        Return the id of the feature.
        &#34;&#34;&#34;
        return self.id

    def set_batchtable_data(self, data):
        &#34;&#34;&#34;
        Set the batch table data associed to this feature.
        :param data: a dictionary
        &#34;&#34;&#34;
        self.batchtable_data = data

    def get_batchtable_data(self):
        &#34;&#34;&#34;
        Return the batch table data associed to this feature.
        :return: a dictionary
        &#34;&#34;&#34;
        return self.batchtable_data

    def get_centroid(self):
        &#34;&#34;&#34;
        Return the centroid of this feature.
        :return: a 3D point as np array
        &#34;&#34;&#34;
        return self.centroid

    def get_bounding_volume_box(self):
        &#34;&#34;&#34;
        Return the BoundingVolumeBox of this feature.
        :return: a BoundingVolumeBox
        &#34;&#34;&#34;
        return self.box

    def get_geom_as_triangles(self):
        &#34;&#34;&#34;
        Return the triangles of this feature.
        :return: a list of triangles
        &#34;&#34;&#34;
        return self.geom.triangles[0]

    def set_triangles(self, triangles):
        &#34;&#34;&#34;
        Set the triangles of this feature.
        :param triangles: a list of triangles.
        &#34;&#34;&#34;
        self.geom.triangles[0] = triangles

    def set_box(self):
        &#34;&#34;&#34;
        Set the BoundingVolumeBox of this feature from its triangles.
        Also set the centroid.
        &#34;&#34;&#34;
        bbox = self.geom.getBbox()
        self.box = BoundingVolumeBox()
        self.box.set_from_mins_maxs(np.append(bbox[0], bbox[1]))

        # Set centroid from Bbox center
        self.centroid = np.array(self.box.get_center())

    def get_texture(self):
        &#34;&#34;&#34;
        Return the texture image of this feature.
        :return: a Pillow image
        &#34;&#34;&#34;
        return self.texture

    def set_texture(self, texture):
        &#34;&#34;&#34;
        Set the texture image of this feature.
        :param texture: a Pillow image
        &#34;&#34;&#34;
        self.texture = texture

    def has_texture(self):
        &#34;&#34;&#34;
        Check if the feature has a texture.
        :return: a boolean
        &#34;&#34;&#34;
        return self.texture is not None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject" href="../CityTiler/citym_cityobject.html#py3dtilers.CityTiler.citym_cityobject.CityMCityObject">CityMCityObject</a></li>
<li><a title="py3dtilers.GeojsonTiler.geojson.Geojson" href="../GeojsonTiler/geojson.html#py3dtilers.GeojsonTiler.geojson.Geojson">Geojson</a></li>
<li><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom" href="../IfcTiler/ifcObjectGeom.html#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom">IfcObjectGeom</a></li>
<li><a title="py3dtilers.ObjTiler.obj.Obj" href="../ObjTiler/obj.html#py3dtilers.ObjTiler.obj.Obj">Obj</a></li>
<li><a title="py3dtilers.TilesetReader.tile_to_feature.TileToFeature" href="../TilesetReader/tile_to_feature.html#py3dtilers.TilesetReader.tile_to_feature.TileToFeature">TileToFeature</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.Feature.get_batchtable_data"><code class="name flex">
<span>def <span class="ident">get_batchtable_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the batch table data associed to this feature.
:return: a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_batchtable_data(self):
    &#34;&#34;&#34;
    Return the batch table data associed to this feature.
    :return: a dictionary
    &#34;&#34;&#34;
    return self.batchtable_data</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.get_bounding_volume_box"><code class="name flex">
<span>def <span class="ident">get_bounding_volume_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the BoundingVolumeBox of this feature.
:return: a BoundingVolumeBox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_volume_box(self):
    &#34;&#34;&#34;
    Return the BoundingVolumeBox of this feature.
    :return: a BoundingVolumeBox
    &#34;&#34;&#34;
    return self.box</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.get_centroid"><code class="name flex">
<span>def <span class="ident">get_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the centroid of this feature.
:return: a 3D point as np array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroid(self):
    &#34;&#34;&#34;
    Return the centroid of this feature.
    :return: a 3D point as np array
    &#34;&#34;&#34;
    return self.centroid</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.get_geom_as_triangles"><code class="name flex">
<span>def <span class="ident">get_geom_as_triangles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the triangles of this feature.
:return: a list of triangles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geom_as_triangles(self):
    &#34;&#34;&#34;
    Return the triangles of this feature.
    :return: a list of triangles
    &#34;&#34;&#34;
    return self.geom.triangles[0]</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the id of the feature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;
    Return the id of the feature.
    &#34;&#34;&#34;
    return self.id</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.get_texture"><code class="name flex">
<span>def <span class="ident">get_texture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the texture image of this feature.
:return: a Pillow image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_texture(self):
    &#34;&#34;&#34;
    Return the texture image of this feature.
    :return: a Pillow image
    &#34;&#34;&#34;
    return self.texture</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.has_texture"><code class="name flex">
<span>def <span class="ident">has_texture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the feature has a texture.
:return: a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_texture(self):
    &#34;&#34;&#34;
    Check if the feature has a texture.
    :return: a boolean
    &#34;&#34;&#34;
    return self.texture is not None</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.set_batchtable_data"><code class="name flex">
<span>def <span class="ident">set_batchtable_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the batch table data associed to this feature.
:param data: a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_batchtable_data(self, data):
    &#34;&#34;&#34;
    Set the batch table data associed to this feature.
    :param data: a dictionary
    &#34;&#34;&#34;
    self.batchtable_data = data</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.set_box"><code class="name flex">
<span>def <span class="ident">set_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the BoundingVolumeBox of this feature from its triangles.
Also set the centroid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_box(self):
    &#34;&#34;&#34;
    Set the BoundingVolumeBox of this feature from its triangles.
    Also set the centroid.
    &#34;&#34;&#34;
    bbox = self.geom.getBbox()
    self.box = BoundingVolumeBox()
    self.box.set_from_mins_maxs(np.append(bbox[0], bbox[1]))

    # Set centroid from Bbox center
    self.centroid = np.array(self.box.get_center())</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.set_id"><code class="name flex">
<span>def <span class="ident">set_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the id of this feature.
:param id: an id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_id(self, id):
    &#34;&#34;&#34;
    Set the id of this feature.
    :param id: an id
    &#34;&#34;&#34;
    self.id = id</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.set_texture"><code class="name flex">
<span>def <span class="ident">set_texture</span></span>(<span>self, texture)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the texture image of this feature.
:param texture: a Pillow image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_texture(self, texture):
    &#34;&#34;&#34;
    Set the texture image of this feature.
    :param texture: a Pillow image
    &#34;&#34;&#34;
    self.texture = texture</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Feature.set_triangles"><code class="name flex">
<span>def <span class="ident">set_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the triangles of this feature.
:param triangles: a list of triangles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_triangles(self, triangles):
    &#34;&#34;&#34;
    Set the triangles of this feature.
    :param triangles: a list of triangles.
    &#34;&#34;&#34;
    self.geom.triangles[0] = triangles</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.FeatureList"><code class="flex name class">
<span>class <span class="ident">FeatureList</span></span>
<span>(</span><span>objects=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorated list of FeatureList type objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureList(object):
    &#34;&#34;&#34;
    A decorated list of FeatureList type objects.
    &#34;&#34;&#34;

    # The material used by default for features
    default_mat = None

    def __init__(self, objects=None):
        self.objects = list()
        if FeatureList.default_mat is None:
            FeatureList.default_mat = ColorConfig().get_default_color()
        self.materials = [FeatureList.default_mat]
        if(objects):
            self.objects.extend(objects)

    def __iter__(self):
        return iter(self.objects)

    def __getitem__(self, item):
        if isinstance(item, slice):
            objects_class = self.__class__
            return objects_class(self.objects.__getitem__(item))
        # item is then an int type:
        return self.objects.__getitem__(item)

    def __add__(self, other):
        objects_class = self.__class__
        new_objects = objects_class(self.objects)
        new_objects.objects.extend(other.objects)
        return new_objects

    def append(self, obj):
        self.objects.append(obj)

    def extend(self, others):
        self.objects.extend(others)

    def get_features(self):
        &#34;&#34;&#34;
        Return (recursively) all the features in this FeatureList.
        :return: a list of Feature instances
        &#34;&#34;&#34;
        if not self.is_list_of_feature_list():
            return self.objects
        else:
            objects = list()
            for objs in self.objects:
                objects.extend(objs.get_features())
            return objects

    def delete_objects_ref(self):
        &#34;&#34;&#34;Delete the reference to the objects contained by this instance, so the objects are destroyed when unused.&#34;&#34;&#34;
        self.objects = list()

    def __len__(self):
        return len(self.objects)

    def is_list_of_feature_list(self):
        &#34;&#34;&#34;Check if this instance of FeatureList contains others FeatureList&#34;&#34;&#34;
        return isinstance(self.objects[0], FeatureList)

    def get_centroid(self):
        &#34;&#34;&#34;
        :param objects: an array containing objs

        :return: the centroid of the tileset.
        &#34;&#34;&#34;
        centroid = [0., 0., 0.]
        for objectToTile in self:
            centroid += objectToTile.get_centroid()
        return np.array([centroid[0] / len(self),
                         centroid[1] / len(self),
                         centroid[2] / len(self)])

    def set_materials(self, materials):
        &#34;&#34;&#34;
        Set the materials of this object to a new array of materials.
        :param materials: an array of GlTFMaterial
        &#34;&#34;&#34;
        self.materials = materials

    def add_materials(self, materials):
        &#34;&#34;&#34;
        Extend the materials of this object with another array of materials.
        :param materials: an array of GlTFMaterial
        &#34;&#34;&#34;
        self.materials.extend(materials)

    def get_material(self, index):
        &#34;&#34;&#34;
        Get the material at the index.
        :param index: the index (int) of the material
        &#34;&#34;&#34;
        return self.materials[index]

    def translate_features(self, offset):
        &#34;&#34;&#34;
        Translate the features by substracting an offset
        :param offset: the Vec3 translation offset
        &#34;&#34;&#34;
        # Translate the position of each object by an offset
        for feature in self.get_features():
            new_geom = []
            for triangle in feature.get_geom_as_triangles():
                new_position = []
                for points in triangle:
                    # Must to do this this way to ensure that the new position
                    # stays in float32, which is mandatory for writing the GLTF
                    new_position.append(np.array(points - offset, dtype=np.float32))
                new_geom.append(new_position)
            feature.set_triangles(new_geom)
            feature.set_box()

    def change_crs(self, transformer):
        &#34;&#34;&#34;
        Project the features into another CRS
        :param transformer: the transformer used to change the crs
        &#34;&#34;&#34;
        for feature in self.get_features():
            new_geom = []
            for triangle in feature.get_geom_as_triangles():
                new_position = []
                for point in triangle:
                    new_point = transformer.transform(point[0], point[1], point[2])
                    new_position.append(np.array(new_point, dtype=np.float32))
                new_geom.append(new_position)
            feature.set_triangles(new_geom)
            feature.set_box()

    def scale_features(self, scale_factor):
        &#34;&#34;&#34;
        Rescale the features.
        :param scale_factor: the factor to scale the objects
        &#34;&#34;&#34;
        centroid = self.get_centroid()
        for feature in self.get_features():
            new_geom = []
            for triangle in feature.get_geom_as_triangles():
                scaled_triangle = [((vertex - centroid) * scale_factor) + centroid for vertex in triangle]
                new_geom.append(scaled_triangle)
            feature.set_triangles(new_geom)
            feature.set_box()

    def get_textures(self):
        &#34;&#34;&#34;
        Return a dictionary of all the textures where the keys are the IDs of the features.
        :return: a dictionary of textures
        &#34;&#34;&#34;
        texture_dict = dict()
        for feature in self.get_features():
            texture_dict[feature.get_id()] = feature.get_texture()
        return texture_dict

    @staticmethod
    def create_batch_table_extension(extension_name, ids=None, objects=None):
        &#34;&#34;&#34;Virtual method to create a batch table extension.&#34;&#34;&#34;
        pass

    @staticmethod
    def create_bounding_volume_extension(extension_name, ids=None, objects=None):
        &#34;&#34;&#34;Virtual method to create a bounding volume box extension.&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects" href="../CityTiler/citym_cityobject.html#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects">CityMCityObjects</a></li>
<li><a title="py3dtilers.GeojsonTiler.geojson.Geojsons" href="../GeojsonTiler/geojson.html#py3dtilers.GeojsonTiler.geojson.Geojsons">Geojsons</a></li>
<li><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom" href="../IfcTiler/ifcObjectGeom.html#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom">IfcObjectsGeom</a></li>
<li><a title="py3dtilers.ObjTiler.obj.Objs" href="../ObjTiler/obj.html#py3dtilers.ObjTiler.obj.Objs">Objs</a></li>
<li><a title="py3dtilers.TilesetReader.tile_to_feature.TileToFeatureList" href="../TilesetReader/tile_to_feature.html#py3dtilers.TilesetReader.tile_to_feature.TileToFeatureList">TileToFeatureList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.Common.FeatureList.default_mat"><code class="name">var <span class="ident">default_mat</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.Common.FeatureList.create_batch_table_extension"><code class="name flex">
<span>def <span class="ident">create_batch_table_extension</span></span>(<span>extension_name, ids=None, objects=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method to create a batch table extension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_batch_table_extension(extension_name, ids=None, objects=None):
    &#34;&#34;&#34;Virtual method to create a batch table extension.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.create_bounding_volume_extension"><code class="name flex">
<span>def <span class="ident">create_bounding_volume_extension</span></span>(<span>extension_name, ids=None, objects=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method to create a bounding volume box extension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_bounding_volume_extension(extension_name, ids=None, objects=None):
    &#34;&#34;&#34;Virtual method to create a bounding volume box extension.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.FeatureList.add_materials"><code class="name flex">
<span>def <span class="ident">add_materials</span></span>(<span>self, materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the materials of this object with another array of materials.
:param materials: an array of GlTFMaterial</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_materials(self, materials):
    &#34;&#34;&#34;
    Extend the materials of this object with another array of materials.
    :param materials: an array of GlTFMaterial
    &#34;&#34;&#34;
    self.materials.extend(materials)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, obj):
    self.objects.append(obj)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.change_crs"><code class="name flex">
<span>def <span class="ident">change_crs</span></span>(<span>self, transformer)</span>
</code></dt>
<dd>
<div class="desc"><p>Project the features into another CRS
:param transformer: the transformer used to change the crs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_crs(self, transformer):
    &#34;&#34;&#34;
    Project the features into another CRS
    :param transformer: the transformer used to change the crs
    &#34;&#34;&#34;
    for feature in self.get_features():
        new_geom = []
        for triangle in feature.get_geom_as_triangles():
            new_position = []
            for point in triangle:
                new_point = transformer.transform(point[0], point[1], point[2])
                new_position.append(np.array(new_point, dtype=np.float32))
            new_geom.append(new_position)
        feature.set_triangles(new_geom)
        feature.set_box()</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.delete_objects_ref"><code class="name flex">
<span>def <span class="ident">delete_objects_ref</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the reference to the objects contained by this instance, so the objects are destroyed when unused.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_objects_ref(self):
    &#34;&#34;&#34;Delete the reference to the objects contained by this instance, so the objects are destroyed when unused.&#34;&#34;&#34;
    self.objects = list()</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, others)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, others):
    self.objects.extend(others)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.get_centroid"><code class="name flex">
<span>def <span class="ident">get_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:param objects: an array containing objs</p>
<p>:return: the centroid of the tileset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroid(self):
    &#34;&#34;&#34;
    :param objects: an array containing objs

    :return: the centroid of the tileset.
    &#34;&#34;&#34;
    centroid = [0., 0., 0.]
    for objectToTile in self:
        centroid += objectToTile.get_centroid()
    return np.array([centroid[0] / len(self),
                     centroid[1] / len(self),
                     centroid[2] / len(self)])</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.get_features"><code class="name flex">
<span>def <span class="ident">get_features</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return (recursively) all the features in this FeatureList.
:return: a list of Feature instances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_features(self):
    &#34;&#34;&#34;
    Return (recursively) all the features in this FeatureList.
    :return: a list of Feature instances
    &#34;&#34;&#34;
    if not self.is_list_of_feature_list():
        return self.objects
    else:
        objects = list()
        for objs in self.objects:
            objects.extend(objs.get_features())
        return objects</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.get_material"><code class="name flex">
<span>def <span class="ident">get_material</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the material at the index.
:param index: the index (int) of the material</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_material(self, index):
    &#34;&#34;&#34;
    Get the material at the index.
    :param index: the index (int) of the material
    &#34;&#34;&#34;
    return self.materials[index]</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.get_textures"><code class="name flex">
<span>def <span class="ident">get_textures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary of all the textures where the keys are the IDs of the features.
:return: a dictionary of textures</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_textures(self):
    &#34;&#34;&#34;
    Return a dictionary of all the textures where the keys are the IDs of the features.
    :return: a dictionary of textures
    &#34;&#34;&#34;
    texture_dict = dict()
    for feature in self.get_features():
        texture_dict[feature.get_id()] = feature.get_texture()
    return texture_dict</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.is_list_of_feature_list"><code class="name flex">
<span>def <span class="ident">is_list_of_feature_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if this instance of FeatureList contains others FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_list_of_feature_list(self):
    &#34;&#34;&#34;Check if this instance of FeatureList contains others FeatureList&#34;&#34;&#34;
    return isinstance(self.objects[0], FeatureList)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.scale_features"><code class="name flex">
<span>def <span class="ident">scale_features</span></span>(<span>self, scale_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale the features.
:param scale_factor: the factor to scale the objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_features(self, scale_factor):
    &#34;&#34;&#34;
    Rescale the features.
    :param scale_factor: the factor to scale the objects
    &#34;&#34;&#34;
    centroid = self.get_centroid()
    for feature in self.get_features():
        new_geom = []
        for triangle in feature.get_geom_as_triangles():
            scaled_triangle = [((vertex - centroid) * scale_factor) + centroid for vertex in triangle]
            new_geom.append(scaled_triangle)
        feature.set_triangles(new_geom)
        feature.set_box()</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.set_materials"><code class="name flex">
<span>def <span class="ident">set_materials</span></span>(<span>self, materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the materials of this object to a new array of materials.
:param materials: an array of GlTFMaterial</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_materials(self, materials):
    &#34;&#34;&#34;
    Set the materials of this object to a new array of materials.
    :param materials: an array of GlTFMaterial
    &#34;&#34;&#34;
    self.materials = materials</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.FeatureList.translate_features"><code class="name flex">
<span>def <span class="ident">translate_features</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate the features by substracting an offset
:param offset: the Vec3 translation offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate_features(self, offset):
    &#34;&#34;&#34;
    Translate the features by substracting an offset
    :param offset: the Vec3 translation offset
    &#34;&#34;&#34;
    # Translate the position of each object by an offset
    for feature in self.get_features():
        new_geom = []
        for triangle in feature.get_geom_as_triangles():
            new_position = []
            for points in triangle:
                # Must to do this this way to ensure that the new position
                # stays in float32, which is mandatory for writing the GLTF
                new_position.append(np.array(points - offset, dtype=np.float32))
            new_geom.append(new_position)
        feature.set_triangles(new_geom)
        feature.set_box()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.FromGeometryTreeToTileset"><code class="flex name class">
<span>class <span class="ident">FromGeometryTreeToTileset</span></span>
</code></dt>
<dd>
<div class="desc"><p>A static class to create a 3DTiles tileset from a GeometryTree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FromGeometryTreeToTileset():
    &#34;&#34;&#34;
    A static class to create a 3DTiles tileset from a GeometryTree.
    &#34;&#34;&#34;

    @staticmethod
    def convert_to_tileset(geometry_tree, extension_name=None):
        &#34;&#34;&#34;
        Recursively creates a tileset from the nodes of a GeometryTree
        :param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
        :param extension_name: the name of an extension to add to the tileset.

        :return: a Tileset
        &#34;&#34;&#34;
        tileset = TileSet()
        centroid = geometry_tree.get_centroid()
        for root_node in geometry_tree.root_nodes:
            FromGeometryTreeToTileset.__create_tile(root_node, tileset, centroid, centroid, 0, extension_name)

        tileset.get_root_tile().set_bounding_volume(BoundingVolumeBox())
        return tileset

    @staticmethod
    def __create_tile(node, parent, centroid, transform_offset, depth, extension_name=None):
        objects = node.feature_list
        objects.translate_features(centroid)

        tile = Tile()
        tile.set_geometric_error(node.geometric_error)

        content_b3dm = FromGeometryTreeToTileset.__create_tile_content(objects, extension_name, node.has_texture())
        tile.set_content(content_b3dm)

        # Set the position of the tile. The position is relative to the parent tile&#39;s position
        tile.set_transform([1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            transform_offset[0], transform_offset[1], transform_offset[2], 1])
        tile.set_refine_mode(&#39;REPLACE&#39;)
        bounding_box = BoundingVolumeBox()
        for feature in objects:
            bounding_box.add(feature.get_bounding_volume_box())

        if extension_name is not None:
            extension = objects.__class__.create_bounding_volume_extension(extension_name, None, objects)
            if extension is not None:
                bounding_box.add_extension(extension)

        tile.set_bounding_volume(bounding_box)

        # If the node is a root of the LodTree, add the created tile to the tileset&#39;s root
        if depth == 0:
            parent.add_tile(tile)
        # Else, add the created tile to its parent&#39;s children
        else:
            parent.add_child(tile)
        node.feature_list.delete_objects_ref()

        for child_node in node.child_nodes:
            FromGeometryTreeToTileset.__create_tile(child_node, tile, centroid, [0., 0., 0.], depth + 1, extension_name)

    @staticmethod
    def __create_tile_content(objects, extension_name=None, with_texture=False):
        &#34;&#34;&#34;
        :param pre_tile: an array containing features of a single tile

        :return: a B3dm tile.
        &#34;&#34;&#34;
        # create B3DM content
        arrays = []
        materials = []
        seen_mat_indexes = []
        if with_texture:
            tile_atlas = Atlas(objects)
            objects.set_materials([GlTFMaterial(textureUri=&#39;./ATLAS_&#39; + str(tile_atlas.tile_number) + &#39;.png&#39;)])
        for feature in objects:
            mat_index = feature.material_index
            if mat_index not in seen_mat_indexes:
                seen_mat_indexes.append(mat_index)
                materials.append(objects.get_material(mat_index))
            content = {
                &#39;position&#39;: feature.geom.getPositionArray(),
                &#39;normal&#39;: feature.geom.getNormalArray(),
                &#39;bbox&#39;: [[float(i) for i in j] for j in feature.geom.getBbox()],
                &#39;matIndex&#39;: mat_index
            }
            if with_texture:
                content[&#39;uv&#39;] = feature.geom.getDataArray(0)
            arrays.append(content)

        # GlTF uses a y-up coordinate system whereas the geographical data (stored
        # in the 3DCityDB database) uses a z-up coordinate system convention. In
        # order to comply with Gltf we thus need to realize a z-up to y-up
        # coordinate transform for the data to respect the glTF convention. This
        # rotation gets &#34;corrected&#34; (taken care of) by the B3dm/gltf parser on the
        # client side when using (displaying) the data.
        # Refer to the note concerning the recommended data workflow
        # https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#gltf-transforms
        # for more details on this matter.
        transform = np.array([1, 0, 0, 0,
                              0, 0, -1, 0,
                              0, 1, 0, 0,
                              0, 0, 0, 1])

        batched = len(materials) &lt;= 1
        gltf = GlTF.from_binary_arrays(arrays, transform, batched=batched, materials=materials)

        # Create a batch table and add the ID of each feature to it
        ids = [feature.get_id() for feature in objects]
        bt = BatchTable()
        bt.add_property_from_array(&#34;id&#34;, ids)

        # if there is application specific data associated with the features, add it to the batch table
        features_data = [feature.get_batchtable_data() for feature in objects]
        if not all([feature_data is None for feature_data in features_data]):
            # Construct a set of all possible batch table keys
            bt_keys = set()
            for key_subset in [feature_data.keys() for feature_data in features_data]:
                bt_keys = bt_keys.union(set(key_subset))
            # add feature data to batch table based on possible keys
            for key in bt_keys:
                key_data = [feature_data.get(key, None) for feature_data in features_data]
                bt.add_property_from_array(key, key_data)

        if extension_name is not None:
            extension = objects.__class__.create_batch_table_extension(extension_name, ids, objects)
            if extension is not None:
                bt.add_extension(extension)

        # Eventually wrap the features together with the optional
        # BatchTableHierarchy within a B3dm:
        return B3dm.from_glTF(gltf, bt)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.Common.FromGeometryTreeToTileset.convert_to_tileset"><code class="name flex">
<span>def <span class="ident">convert_to_tileset</span></span>(<span>geometry_tree, extension_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively creates a tileset from the nodes of a GeometryTree
:param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
:param extension_name: the name of an extension to add to the tileset.</p>
<p>:return: a Tileset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_to_tileset(geometry_tree, extension_name=None):
    &#34;&#34;&#34;
    Recursively creates a tileset from the nodes of a GeometryTree
    :param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
    :param extension_name: the name of an extension to add to the tileset.

    :return: a Tileset
    &#34;&#34;&#34;
    tileset = TileSet()
    centroid = geometry_tree.get_centroid()
    for root_node in geometry_tree.root_nodes:
        FromGeometryTreeToTileset.__create_tile(root_node, tileset, centroid, centroid, 0, extension_name)

    tileset.get_root_tile().set_bounding_volume(BoundingVolumeBox())
    return tileset</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.GeometryNode"><code class="flex name class">
<span>class <span class="ident">GeometryNode</span></span>
<span>(</span><span>feature_list=None, geometric_error=50, with_texture=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Each node contains an instance of FeatureList
and a list of child nodes.
A node will correspond to a tile of the 3dtiles tileset.</p>
<p>:param feature_list: an instance of FeatureList.
:param geometric_error: the distance below which this node should be displayed.
:param Boolean with_texture: if this node must keep the texture of the features or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryNode():
    &#34;&#34;&#34;
    Each node contains an instance of FeatureList
    and a list of child nodes.
    A node will correspond to a tile of the 3dtiles tileset.
    &#34;&#34;&#34;

    def __init__(self, feature_list=None, geometric_error=50, with_texture=False):
        &#34;&#34;&#34;
        :param feature_list: an instance of FeatureList.
        :param geometric_error: the distance below which this node should be displayed.
        :param Boolean with_texture: if this node must keep the texture of the features or not.
        &#34;&#34;&#34;
        self.feature_list = feature_list
        self.child_nodes = list()
        self.with_texture = with_texture and self.geometries_have_texture()
        self.geometric_error = geometric_error

    def set_child_nodes(self, nodes=list()):
        &#34;&#34;&#34;
        Set the child nodes of this node.
        :param nodes: list of nodes
        &#34;&#34;&#34;
        self.child_nodes = nodes

    def add_child_node(self, node):
        &#34;&#34;&#34;
        Add a child to the child nodes.
        :param node: a node
        &#34;&#34;&#34;
        self.child_nodes.append(node)

    def has_texture(self):
        &#34;&#34;&#34;
        Return True if this node must keep the texture of its features.
        :return: boolean
        &#34;&#34;&#34;
        return self.with_texture

    def geometries_have_texture(self):
        &#34;&#34;&#34;
        Check if all the features in the node have a texture.
        :return: a boolean
        &#34;&#34;&#34;
        return all([feature.has_texture() for feature in self.feature_list])

    def get_features(self):
        &#34;&#34;&#34;
        Return the features in this node and the features in the child nodes (recursively).
        :return: a FeatureList
        &#34;&#34;&#34;
        objects = [self.feature_list]
        for child in self.child_nodes:
            objects.extend(child.get_features())
        return objects

    def get_leaves(self):
        &#34;&#34;&#34;
        Return the leaves of this node.
        If the node has no child, return this node.
        :return: a list of GeometryNode
        &#34;&#34;&#34;
        if len(self.child_nodes) &lt; 1:
            return [self]
        else:
            leaves = list()
            for node in self.child_nodes:
                leaves.extend(node.get_leaves())
            return leaves</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.lod_node.LoaNode" href="lod_node.html#py3dtilers.Common.lod_node.LoaNode">LoaNode</a></li>
<li><a title="py3dtilers.Common.lod_node.Lod1Node" href="lod_node.html#py3dtilers.Common.lod_node.Lod1Node">Lod1Node</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.GeometryNode.add_child_node"><code class="name flex">
<span>def <span class="ident">add_child_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a child to the child nodes.
:param node: a node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child_node(self, node):
    &#34;&#34;&#34;
    Add a child to the child nodes.
    :param node: a node
    &#34;&#34;&#34;
    self.child_nodes.append(node)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryNode.geometries_have_texture"><code class="name flex">
<span>def <span class="ident">geometries_have_texture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if all the features in the node have a texture.
:return: a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geometries_have_texture(self):
    &#34;&#34;&#34;
    Check if all the features in the node have a texture.
    :return: a boolean
    &#34;&#34;&#34;
    return all([feature.has_texture() for feature in self.feature_list])</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryNode.get_features"><code class="name flex">
<span>def <span class="ident">get_features</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the features in this node and the features in the child nodes (recursively).
:return: a FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_features(self):
    &#34;&#34;&#34;
    Return the features in this node and the features in the child nodes (recursively).
    :return: a FeatureList
    &#34;&#34;&#34;
    objects = [self.feature_list]
    for child in self.child_nodes:
        objects.extend(child.get_features())
    return objects</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryNode.get_leaves"><code class="name flex">
<span>def <span class="ident">get_leaves</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the leaves of this node.
If the node has no child, return this node.
:return: a list of GeometryNode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_leaves(self):
    &#34;&#34;&#34;
    Return the leaves of this node.
    If the node has no child, return this node.
    :return: a list of GeometryNode
    &#34;&#34;&#34;
    if len(self.child_nodes) &lt; 1:
        return [self]
    else:
        leaves = list()
        for node in self.child_nodes:
            leaves.extend(node.get_leaves())
        return leaves</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryNode.has_texture"><code class="name flex">
<span>def <span class="ident">has_texture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if this node must keep the texture of its features.
:return: boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_texture(self):
    &#34;&#34;&#34;
    Return True if this node must keep the texture of its features.
    :return: boolean
    &#34;&#34;&#34;
    return self.with_texture</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryNode.set_child_nodes"><code class="name flex">
<span>def <span class="ident">set_child_nodes</span></span>(<span>self, nodes=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the child nodes of this node.
:param nodes: list of nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_child_nodes(self, nodes=list()):
    &#34;&#34;&#34;
    Set the child nodes of this node.
    :param nodes: list of nodes
    &#34;&#34;&#34;
    self.child_nodes = nodes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.GeometryTree"><code class="flex name class">
<span>class <span class="ident">GeometryTree</span></span>
<span>(</span><span>root_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>The GeometryTree contains a list of GeometryNode instances.
Those instances are the root nodes of a tree.
The GeometryTree also contains the centroid of the root nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryTree():
    &#34;&#34;&#34;
    The GeometryTree contains a list of GeometryNode instances.
    Those instances are the root nodes of a tree.
    The GeometryTree also contains the centroid of the root nodes.
    &#34;&#34;&#34;

    def __init__(self, root_nodes):
        self.root_nodes = root_nodes

    def get_centroid(self):
        &#34;&#34;&#34;
        Return the centroid of the tree.
        The centroid of the tree is the centroid of the root nodes features.
        &#34;&#34;&#34;
        return self.get_root_objects().get_centroid()

    def get_leaf_nodes(self):
        &#34;&#34;&#34;
        Return the leaf nodes of the tree.
        :return: a list of GeometryNode
        &#34;&#34;&#34;
        leaf_nodes = list()
        for node in self.root_nodes:
            leaf_nodes.extend(node.get_leaves())
        return leaf_nodes

    def get_root_objects(self):
        &#34;&#34;&#34;
        Return the features of the root nodes.
        :return: a FeatureList
        &#34;&#34;&#34;
        return FeatureList([node.feature_list for node in self.root_nodes])

    def get_leaf_objects(self):
        &#34;&#34;&#34;
        Return the features of the leaf nodes.
        :return: a FeatureList
        &#34;&#34;&#34;
        return FeatureList([node.feature_list for node in self.get_leaf_nodes()])

    def get_all_objects(self):
        &#34;&#34;&#34;
        Return the features of all the nodes.
        :return: a FeatureList
        &#34;&#34;&#34;
        objects = list()
        for node in self.root_nodes:
            objects.extend(node.get_features())
        return FeatureList(objects)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.lod_tree.LodTree" href="lod_tree.html#py3dtilers.Common.lod_tree.LodTree">LodTree</a></li>
<li><a title="py3dtilers.TilesetReader.tileset_tree.TilesetTree" href="../TilesetReader/tileset_tree.html#py3dtilers.TilesetReader.tileset_tree.TilesetTree">TilesetTree</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.GeometryTree.get_all_objects"><code class="name flex">
<span>def <span class="ident">get_all_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the features of all the nodes.
:return: a FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_objects(self):
    &#34;&#34;&#34;
    Return the features of all the nodes.
    :return: a FeatureList
    &#34;&#34;&#34;
    objects = list()
    for node in self.root_nodes:
        objects.extend(node.get_features())
    return FeatureList(objects)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryTree.get_centroid"><code class="name flex">
<span>def <span class="ident">get_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the centroid of the tree.
The centroid of the tree is the centroid of the root nodes features.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroid(self):
    &#34;&#34;&#34;
    Return the centroid of the tree.
    The centroid of the tree is the centroid of the root nodes features.
    &#34;&#34;&#34;
    return self.get_root_objects().get_centroid()</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryTree.get_leaf_nodes"><code class="name flex">
<span>def <span class="ident">get_leaf_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the leaf nodes of the tree.
:return: a list of GeometryNode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_leaf_nodes(self):
    &#34;&#34;&#34;
    Return the leaf nodes of the tree.
    :return: a list of GeometryNode
    &#34;&#34;&#34;
    leaf_nodes = list()
    for node in self.root_nodes:
        leaf_nodes.extend(node.get_leaves())
    return leaf_nodes</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryTree.get_leaf_objects"><code class="name flex">
<span>def <span class="ident">get_leaf_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the features of the leaf nodes.
:return: a FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_leaf_objects(self):
    &#34;&#34;&#34;
    Return the features of the leaf nodes.
    :return: a FeatureList
    &#34;&#34;&#34;
    return FeatureList([node.feature_list for node in self.get_leaf_nodes()])</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.GeometryTree.get_root_objects"><code class="name flex">
<span>def <span class="ident">get_root_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the features of the root nodes.
:return: a FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_objects(self):
    &#34;&#34;&#34;
    Return the features of the root nodes.
    :return: a FeatureList
    &#34;&#34;&#34;
    return FeatureList([node.feature_list for node in self.root_nodes])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.Groups"><code class="flex name class">
<span>class <span class="ident">Groups</span></span>
<span>(</span><span>feature_list, polygons_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of Group</p>
<p>Distribute the features contained in feature_list into different Group
The way to distribute the features depends on the parameters
:param feature_list: an instance of FeatureList containing features to distribute into Group
:param polygons_path: the path to a folder containing polygons as .geojson files.
When this param is not None, it means we want to group features by polygons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Groups():
    &#34;&#34;&#34;
    Contains a list of Group
    &#34;&#34;&#34;

    def __init__(self, feature_list, polygons_path=None):
        &#34;&#34;&#34;
        Distribute the features contained in feature_list into different Group
        The way to distribute the features depends on the parameters
        :param feature_list: an instance of FeatureList containing features to distribute into Group
        :param polygons_path: the path to a folder containing polygons as .geojson files.
        When this param is not None, it means we want to group features by polygons
        &#34;&#34;&#34;
        self.materials = feature_list.materials
        if feature_list.is_list_of_feature_list():
            self.group_objects_by_instance(feature_list)
        elif polygons_path is not None:
            self.group_objects_by_polygons(feature_list, polygons_path)
        else:
            self.group_objects_with_kdtree(feature_list)
        self.set_materials(self.materials)

    def get_groups_as_list(self):
        &#34;&#34;&#34;
        Return the groups as a list.
        :return: the groups as list
        &#34;&#34;&#34;
        return self.groups

    def set_materials(self, materials):
        &#34;&#34;&#34;
        Set the materials of each group.
        :param materials: an array of all the materials
        &#34;&#34;&#34;
        for group in self.groups:
            group.add_materials(materials)

    def group_objects_by_instance(self, feature_list):
        &#34;&#34;&#34;
        Create groups of features. One group is created per object in the FeatureList.
        &#34;&#34;&#34;
        groups = list()
        for objects in feature_list:
            group = Group(objects)
            groups.append(group)
        self.groups = groups

    def group_objects_with_kdtree(self, feature_list):
        &#34;&#34;&#34;
        Create groups of features. The features are distributed into groups of (max) 500 objects.
        The distribution depends on the centroid of each feature.
        &#34;&#34;&#34;
        groups = list()
        objects = kd_tree(feature_list, 500)
        for feature_list in objects:
            group = Group(feature_list)
            groups.append(group)
        self.groups = groups

    def group_objects_by_polygons(self, feature_list, polygons_path):
        &#34;&#34;&#34;
        Load the polygons from the files in the folder
        :param polygons_path: the path to the file(s) containing polygons
        &#34;&#34;&#34;
        polygons = list()
        files = []

        if(os.path.isdir(polygons_path)):
            geojson_dir = listdir(polygons_path)
            for geojson_file in geojson_dir:
                file_path = os.path.join(polygons_path, geojson_file)
                if(os.path.isfile(file_path)):
                    files.append(file_path)
        else:
            files.append(polygons_path)

        # Read all the polygons in the file(s)
        for file in files:
            if(&#34;.geojson&#34; in file or &#34;.json&#34; in file):
                with open(file) as f:
                    gjContent = json.load(f)
                for feature in gjContent[&#39;features&#39;]:
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;Polygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][:-1]
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;MultiPolygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][0][:-1]
                    polygons.append(Polygon(coords))
        self.groups = self.distribute_objects_in_polygons(feature_list, polygons)

    def distribute_objects_in_polygons(self, feature_list, polygons):
        &#34;&#34;&#34;
        Distribute the features in the polygons.
        The features in the same polygon are grouped together. The Group created will also contain the points of the polygon.
        If a feature is not in any polygon, create a Group containing only this feature. This group won&#39;t have addtional points.
        :param polygons: a list of Shapely polygons
        &#34;&#34;&#34;

        objects_to_tile_dict = {}
        objects_to_tile_without_poly = {}

        # For each feature, find the polygon containing it
        for i, feature in enumerate(feature_list):
            p = Point(feature.get_centroid())
            in_polygon = False
            for index, polygon in enumerate(polygons):
                if p.within(polygon):
                    if index in objects_to_tile_dict:
                        objects_to_tile_dict[index].append(i)
                    else:
                        objects_to_tile_dict[index] = [i]
                    in_polygon = True
                    break
            if not in_polygon:
                objects_to_tile_without_poly[i] = [i]

        # Create a list of Group
        groups = list()
        for key in objects_to_tile_dict:
            additional_points = polygons[key].exterior.coords[:-1]
            contained_objects = FeatureList([feature_list[i] for i in objects_to_tile_dict[key]])
            group = Group(contained_objects, with_polygon=True, additional_points=additional_points)
            groups.append(group)
        for key in objects_to_tile_without_poly:
            contained_objects = FeatureList([feature_list[i] for i in objects_to_tile_without_poly[key]])
            group = Group(contained_objects)
            groups.append(group)

        return self.distribute_groups_in_cubes(groups, 300)

    def distribute_groups_in_cubes(self, groups, cube_size=300):
        &#34;&#34;&#34;
        Merges together the groups in order to reduce the number of tiles.
        The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
        To avoid conflicts, the groups with a polygon are not merged with those without polygon.
        :param groups: the groups to distribute into cubes
        :param cube_size: the size of the cubes

        :return: merged groups
        &#34;&#34;&#34;
        groups_dict = {}

        # Create a dictionary key: cubes center (x,y,z), with geometry (boolean); value: list of groups index
        for i in range(0, len(groups)):
            closest_cube = groups[i].round_coordinates(groups[i].get_centroid(), cube_size)
            with_polygon = groups[i].with_polygon
            if (tuple(closest_cube), with_polygon) in groups_dict:
                groups_dict[(tuple(closest_cube), with_polygon)].append(i)
            else:
                groups_dict[(tuple(closest_cube), with_polygon)] = [i]

        # Merge the groups in the same cube and create new groups
        groups_in_cube = list()
        for cube in groups_dict:
            with_polygon = cube[1]
            groups_in_cube.append(self.merge_groups_together(groups, groups_dict[cube], with_polygon))

        return groups_in_cube

    def merge_groups_together(self, groups, group_indexes, with_polygon):
        &#34;&#34;&#34;
        Creates a Group from a list of Groups
        :param groups: all the groups
        :param group_indexes: the indexes of the groups to merge together
        :param Boolean with_polygon: when creating LOA (with_polygon=True), add the polygons to the new group

        :return: a new group containing the features of all the groups
        &#34;&#34;&#34;

        objects = list()
        additional_points_list = list()
        additional_points_dict = dict()

        for index in group_indexes:
            if with_polygon:
                additional_points_list.append(groups[index].additional_points)
                points_index = len(additional_points_list) - 1
                additional_points_dict[points_index] = []
                for feature in groups[index].feature_list:
                    objects.append(feature)
                    additional_points_dict[points_index].append(len(objects) - 1)
            else:
                for feature in groups[index].feature_list:
                    objects.append(feature)
        return Group(FeatureList(objects), with_polygon=with_polygon, additional_points=additional_points_list, points_dict=additional_points_dict)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.Groups.distribute_groups_in_cubes"><code class="name flex">
<span>def <span class="ident">distribute_groups_in_cubes</span></span>(<span>self, groups, cube_size=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges together the groups in order to reduce the number of tiles.
The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
To avoid conflicts, the groups with a polygon are not merged with those without polygon.
:param groups: the groups to distribute into cubes
:param cube_size: the size of the cubes</p>
<p>:return: merged groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute_groups_in_cubes(self, groups, cube_size=300):
    &#34;&#34;&#34;
    Merges together the groups in order to reduce the number of tiles.
    The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
    To avoid conflicts, the groups with a polygon are not merged with those without polygon.
    :param groups: the groups to distribute into cubes
    :param cube_size: the size of the cubes

    :return: merged groups
    &#34;&#34;&#34;
    groups_dict = {}

    # Create a dictionary key: cubes center (x,y,z), with geometry (boolean); value: list of groups index
    for i in range(0, len(groups)):
        closest_cube = groups[i].round_coordinates(groups[i].get_centroid(), cube_size)
        with_polygon = groups[i].with_polygon
        if (tuple(closest_cube), with_polygon) in groups_dict:
            groups_dict[(tuple(closest_cube), with_polygon)].append(i)
        else:
            groups_dict[(tuple(closest_cube), with_polygon)] = [i]

    # Merge the groups in the same cube and create new groups
    groups_in_cube = list()
    for cube in groups_dict:
        with_polygon = cube[1]
        groups_in_cube.append(self.merge_groups_together(groups, groups_dict[cube], with_polygon))

    return groups_in_cube</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.distribute_objects_in_polygons"><code class="name flex">
<span>def <span class="ident">distribute_objects_in_polygons</span></span>(<span>self, feature_list, polygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Distribute the features in the polygons.
The features in the same polygon are grouped together. The Group created will also contain the points of the polygon.
If a feature is not in any polygon, create a Group containing only this feature. This group won't have addtional points.
:param polygons: a list of Shapely polygons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute_objects_in_polygons(self, feature_list, polygons):
    &#34;&#34;&#34;
    Distribute the features in the polygons.
    The features in the same polygon are grouped together. The Group created will also contain the points of the polygon.
    If a feature is not in any polygon, create a Group containing only this feature. This group won&#39;t have addtional points.
    :param polygons: a list of Shapely polygons
    &#34;&#34;&#34;

    objects_to_tile_dict = {}
    objects_to_tile_without_poly = {}

    # For each feature, find the polygon containing it
    for i, feature in enumerate(feature_list):
        p = Point(feature.get_centroid())
        in_polygon = False
        for index, polygon in enumerate(polygons):
            if p.within(polygon):
                if index in objects_to_tile_dict:
                    objects_to_tile_dict[index].append(i)
                else:
                    objects_to_tile_dict[index] = [i]
                in_polygon = True
                break
        if not in_polygon:
            objects_to_tile_without_poly[i] = [i]

    # Create a list of Group
    groups = list()
    for key in objects_to_tile_dict:
        additional_points = polygons[key].exterior.coords[:-1]
        contained_objects = FeatureList([feature_list[i] for i in objects_to_tile_dict[key]])
        group = Group(contained_objects, with_polygon=True, additional_points=additional_points)
        groups.append(group)
    for key in objects_to_tile_without_poly:
        contained_objects = FeatureList([feature_list[i] for i in objects_to_tile_without_poly[key]])
        group = Group(contained_objects)
        groups.append(group)

    return self.distribute_groups_in_cubes(groups, 300)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.get_groups_as_list"><code class="name flex">
<span>def <span class="ident">get_groups_as_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the groups as a list.
:return: the groups as list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups_as_list(self):
    &#34;&#34;&#34;
    Return the groups as a list.
    :return: the groups as list
    &#34;&#34;&#34;
    return self.groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.group_objects_by_instance"><code class="name flex">
<span>def <span class="ident">group_objects_by_instance</span></span>(<span>self, feature_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Create groups of features. One group is created per object in the FeatureList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_by_instance(self, feature_list):
    &#34;&#34;&#34;
    Create groups of features. One group is created per object in the FeatureList.
    &#34;&#34;&#34;
    groups = list()
    for objects in feature_list:
        group = Group(objects)
        groups.append(group)
    self.groups = groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.group_objects_by_polygons"><code class="name flex">
<span>def <span class="ident">group_objects_by_polygons</span></span>(<span>self, feature_list, polygons_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the polygons from the files in the folder
:param polygons_path: the path to the file(s) containing polygons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_by_polygons(self, feature_list, polygons_path):
    &#34;&#34;&#34;
    Load the polygons from the files in the folder
    :param polygons_path: the path to the file(s) containing polygons
    &#34;&#34;&#34;
    polygons = list()
    files = []

    if(os.path.isdir(polygons_path)):
        geojson_dir = listdir(polygons_path)
        for geojson_file in geojson_dir:
            file_path = os.path.join(polygons_path, geojson_file)
            if(os.path.isfile(file_path)):
                files.append(file_path)
    else:
        files.append(polygons_path)

    # Read all the polygons in the file(s)
    for file in files:
        if(&#34;.geojson&#34; in file or &#34;.json&#34; in file):
            with open(file) as f:
                gjContent = json.load(f)
            for feature in gjContent[&#39;features&#39;]:
                if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;Polygon&#39;:
                    coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][:-1]
                if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;MultiPolygon&#39;:
                    coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][0][:-1]
                polygons.append(Polygon(coords))
    self.groups = self.distribute_objects_in_polygons(feature_list, polygons)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.group_objects_with_kdtree"><code class="name flex">
<span>def <span class="ident">group_objects_with_kdtree</span></span>(<span>self, feature_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Create groups of features. The features are distributed into groups of (max) 500 objects.
The distribution depends on the centroid of each feature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_with_kdtree(self, feature_list):
    &#34;&#34;&#34;
    Create groups of features. The features are distributed into groups of (max) 500 objects.
    The distribution depends on the centroid of each feature.
    &#34;&#34;&#34;
    groups = list()
    objects = kd_tree(feature_list, 500)
    for feature_list in objects:
        group = Group(feature_list)
        groups.append(group)
    self.groups = groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.merge_groups_together"><code class="name flex">
<span>def <span class="ident">merge_groups_together</span></span>(<span>self, groups, group_indexes, with_polygon)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Group from a list of Groups
:param groups: all the groups
:param group_indexes: the indexes of the groups to merge together
:param Boolean with_polygon: when creating LOA (with_polygon=True), add the polygons to the new group</p>
<p>:return: a new group containing the features of all the groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_groups_together(self, groups, group_indexes, with_polygon):
    &#34;&#34;&#34;
    Creates a Group from a list of Groups
    :param groups: all the groups
    :param group_indexes: the indexes of the groups to merge together
    :param Boolean with_polygon: when creating LOA (with_polygon=True), add the polygons to the new group

    :return: a new group containing the features of all the groups
    &#34;&#34;&#34;

    objects = list()
    additional_points_list = list()
    additional_points_dict = dict()

    for index in group_indexes:
        if with_polygon:
            additional_points_list.append(groups[index].additional_points)
            points_index = len(additional_points_list) - 1
            additional_points_dict[points_index] = []
            for feature in groups[index].feature_list:
                objects.append(feature)
                additional_points_dict[points_index].append(len(objects) - 1)
        else:
            for feature in groups[index].feature_list:
                objects.append(feature)
    return Group(FeatureList(objects), with_polygon=with_polygon, additional_points=additional_points_list, points_dict=additional_points_dict)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Groups.set_materials"><code class="name flex">
<span>def <span class="ident">set_materials</span></span>(<span>self, materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the materials of each group.
:param materials: an array of all the materials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_materials(self, materials):
    &#34;&#34;&#34;
    Set the materials of each group.
    :param materials: an array of all the materials
    &#34;&#34;&#34;
    for group in self.groups:
        group.add_materials(materials)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.LoaNode"><code class="flex name class">
<span>class <span class="ident">LoaNode</span></span>
<span>(</span><span>feature_list, geometric_error=50, additional_points=[], points_dict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Creates 3D extrusions of the polygons given as parameter.
The LoaNode also takes a dictionary stocking the indexes of the features contained in each polygon.</p>
<p>:param feature_list: an instance of FeatureList.
:param geometric_error: the distance below which this node should be displayed.
:param Boolean with_texture: if this node must keep the texture of the features or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoaNode(GeometryNode):
    &#34;&#34;&#34;
    Creates 3D extrusions of the polygons given as parameter.
    The LoaNode also takes a dictionary stocking the indexes of the features contained in each polygon.
    &#34;&#34;&#34;
    loa_index = 0

    def __init__(self, feature_list, geometric_error=50, additional_points=list(), points_dict=dict()):
        loas = list()
        for key in points_dict:
            contained_objects = FeatureList([feature_list[i] for i in points_dict[key]])
            loa = self.create_loa_from_polygon(contained_objects, additional_points[key], LoaNode.loa_index)
            loas.append(loa)
            LoaNode.loa_index += 1
        super().__init__(feature_list=FeatureList(loas), geometric_error=geometric_error)

    def create_loa_from_polygon(self, feature_list, polygon_points, index=0):
        &#34;&#34;&#34;
        Create a LOA (3D extrusion of a polygon). The LOA is a 3D geometry containing a group of features.
        :param feature_list: the features contained in the LOA
        :param polygon_points: a polygon as list of 3D points
        :param int index: an index used for the LOA identifier

        :return: a 3D extrusion of the polygon
        &#34;&#34;&#34;
        loa_geometry = Feature(&#34;loa_&#34; + str(index))
        for feature in feature_list:
            loa_geometry.geom.triangles.append(feature.geom.triangles[0])

        extruded_polygon = ExtrudedPolygon(loa_geometry, override_points=True, polygon=polygon_points)
        return extruded_polygon.get_extruded_object()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.geometry_node.GeometryNode" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode">GeometryNode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.Common.LoaNode.loa_index"><code class="name">var <span class="ident">loa_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.LoaNode.create_loa_from_polygon"><code class="name flex">
<span>def <span class="ident">create_loa_from_polygon</span></span>(<span>self, feature_list, polygon_points, index=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a LOA (3D extrusion of a polygon). The LOA is a 3D geometry containing a group of features.
:param feature_list: the features contained in the LOA
:param polygon_points: a polygon as list of 3D points
:param int index: an index used for the LOA identifier</p>
<p>:return: a 3D extrusion of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_loa_from_polygon(self, feature_list, polygon_points, index=0):
    &#34;&#34;&#34;
    Create a LOA (3D extrusion of a polygon). The LOA is a 3D geometry containing a group of features.
    :param feature_list: the features contained in the LOA
    :param polygon_points: a polygon as list of 3D points
    :param int index: an index used for the LOA identifier

    :return: a 3D extrusion of the polygon
    &#34;&#34;&#34;
    loa_geometry = Feature(&#34;loa_&#34; + str(index))
    for feature in feature_list:
        loa_geometry.geom.triangles.append(feature.geom.triangles[0])

    extruded_polygon = ExtrudedPolygon(loa_geometry, override_points=True, polygon=polygon_points)
    return extruded_polygon.get_extruded_object()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.geometry_node.GeometryNode" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode">GeometryNode</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.add_child_node" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.add_child_node">add_child_node</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.geometries_have_texture" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.geometries_have_texture">geometries_have_texture</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.get_features" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.get_features">get_features</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.get_leaves" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.get_leaves">get_leaves</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.has_texture" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.has_texture">has_texture</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.set_child_nodes" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.set_child_nodes">set_child_nodes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="py3dtilers.Common.Lod1Node"><code class="flex name class">
<span>class <span class="ident">Lod1Node</span></span>
<span>(</span><span>feature_list, geometric_error=50)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates 3D extrusions of the footprint of each feature in the feature_list parameter of the constructor.</p>
<p>:param feature_list: an instance of FeatureList.
:param geometric_error: the distance below which this node should be displayed.
:param Boolean with_texture: if this node must keep the texture of the features or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lod1Node(GeometryNode):
    &#34;&#34;&#34;
    Creates 3D extrusions of the footprint of each feature in the feature_list parameter of the constructor.
    &#34;&#34;&#34;

    def __init__(self, feature_list, geometric_error=50):
        lod1_list = list()
        for feature in feature_list:
            extruded_polygon = ExtrudedPolygon(feature)
            lod1_list.append(extruded_polygon.get_extruded_object())
        super().__init__(feature_list=FeatureList(lod1_list), geometric_error=geometric_error)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.geometry_node.GeometryNode" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode">GeometryNode</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.geometry_node.GeometryNode" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode">GeometryNode</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.add_child_node" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.add_child_node">add_child_node</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.geometries_have_texture" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.geometries_have_texture">geometries_have_texture</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.get_features" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.get_features">get_features</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.get_leaves" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.get_leaves">get_leaves</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.has_texture" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.has_texture">has_texture</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node.GeometryNode.set_child_nodes" href="geometry_node.html#py3dtilers.Common.geometry_node.GeometryNode.set_child_nodes">set_child_nodes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="py3dtilers.Common.LodTree"><code class="flex name class">
<span>class <span class="ident">LodTree</span></span>
<span>(</span><span>feature_list, create_lod1=False, create_loa=False, polygons_path=None, with_texture=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The LodTree contains the root node(s) of the LOD hierarchy and the centroid of the whole tileset</p>
<p>LodTree takes an instance of FeatureList (which contains a collection of Feature) and creates nodes.
In order to reduce the number of .b3dm, it also distributes the features into a list of Group.
A Group contains features and an optional polygon that will be used for LoaNodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LodTree(GeometryTree):
    &#34;&#34;&#34;
    The LodTree contains the root node(s) of the LOD hierarchy and the centroid of the whole tileset
    &#34;&#34;&#34;

    def __init__(self, feature_list, create_lod1=False, create_loa=False, polygons_path=None, with_texture=False):
        &#34;&#34;&#34;
        LodTree takes an instance of FeatureList (which contains a collection of Feature) and creates nodes.
        In order to reduce the number of .b3dm, it also distributes the features into a list of Group.
        A Group contains features and an optional polygon that will be used for LoaNodes.
        &#34;&#34;&#34;
        root_nodes = list()

        groups = self.group_features(feature_list, polygons_path)

        for group in groups:
            node = GeometryNode(group.feature_list, 1, with_texture)
            root_node = node
            if create_lod1:
                lod1_node = Lod1Node(group.feature_list, 5)
                lod1_node.add_child_node(root_node)
                root_node = lod1_node
            if group.with_polygon:
                loa_node = LoaNode(group.feature_list, 20, group.additional_points, group.points_dict)
                loa_node.add_child_node(root_node)
                root_node = loa_node

            root_nodes.append(root_node)

        super().__init__(root_nodes)

    def group_features(self, feature_list, polygons_path=None):
        &#34;&#34;&#34;
        Distribute feature_list into groups to reduce the number of tiles.
        :param feature_list: a FeatureList to distribute into groups.
        :param polygons_path: a path to the file(s) containing polygons (used for LOA creation)

        :return: a list of groups, each group containing features
        &#34;&#34;&#34;
        groups = Groups(feature_list, polygons_path)
        return groups.get_groups_as_list()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.geometry_tree.GeometryTree" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree">GeometryTree</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.LodTree.group_features"><code class="name flex">
<span>def <span class="ident">group_features</span></span>(<span>self, feature_list, polygons_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Distribute feature_list into groups to reduce the number of tiles.
:param feature_list: a FeatureList to distribute into groups.
:param polygons_path: a path to the file(s) containing polygons (used for LOA creation)</p>
<p>:return: a list of groups, each group containing features</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_features(self, feature_list, polygons_path=None):
    &#34;&#34;&#34;
    Distribute feature_list into groups to reduce the number of tiles.
    :param feature_list: a FeatureList to distribute into groups.
    :param polygons_path: a path to the file(s) containing polygons (used for LOA creation)

    :return: a list of groups, each group containing features
    &#34;&#34;&#34;
    groups = Groups(feature_list, polygons_path)
    return groups.get_groups_as_list()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.geometry_tree.GeometryTree" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree">GeometryTree</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.geometry_tree.GeometryTree.get_all_objects" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree.get_all_objects">get_all_objects</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_tree.GeometryTree.get_centroid" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_tree.GeometryTree.get_leaf_nodes" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree.get_leaf_nodes">get_leaf_nodes</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_tree.GeometryTree.get_leaf_objects" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree.get_leaf_objects">get_leaf_objects</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_tree.GeometryTree.get_root_objects" href="geometry_tree.html#py3dtilers.Common.geometry_tree.GeometryTree.get_root_objects">get_root_objects</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="py3dtilers.Common.ObjWriter"><code class="flex name class">
<span>class <span class="ident">ObjWriter</span></span>
</code></dt>
<dd>
<div class="desc"><p>A writer which write triangles from Feature instances into an OBJ file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObjWriter():
    &#34;&#34;&#34;
    A writer which write triangles from Feature instances into an OBJ file
    &#34;&#34;&#34;

    def __init__(self):
        self.vertices = list()
        self.triangles = list()
        self.vertex_indexes = {}
        self.index = 0
        self.centroid = [0, 0, 0]
        self.nb_geometries = 0

    def get_centroid(self):
        &#34;&#34;&#34;
        Compute and return the normalized centroid of the OBJ.
        :return: the centroid
        &#34;&#34;&#34;
        self.centroid[:] = [c / self.nb_geometries for c in self.centroid]
        return self.centroid

    def add_to_centroid(self, geom_centroid):
        &#34;&#34;&#34;
        Add the centroid of a geometry to the centroid of the OBJ.
        :param geom_centroid: the centroid of the geometry
        &#34;&#34;&#34;
        self.nb_geometries += 1
        for i, coord in enumerate(geom_centroid):
            self.centroid[i] += coord

    def get_index(self):
        &#34;&#34;&#34;
        Return an index for new vertex.
        :return: the index
        &#34;&#34;&#34;
        self.index += 1
        return self.index

    def get_vertex_index(self, vertex):
        &#34;&#34;&#34;
        Return the index associated to a vertex.
        If no index is associated to the vertex, create a new index.
        :param vertex: the vertex

        :return: the index associated to the vertex
        &#34;&#34;&#34;
        vertex = vertex.tolist()
        if not tuple(vertex) in self.vertex_indexes:
            self.vertex_indexes[tuple(vertex)] = self.get_index()
            self.vertices.append(vertex)

        return self.vertex_indexes[tuple(vertex)]

    def add_triangle(self, triangle):
        &#34;&#34;&#34;
        Add a triangle to the OBJ.
        :param triangle: the triangle
        &#34;&#34;&#34;
        indexes = list()
        for vertex in triangle:
            indexes.append(self.get_vertex_index(vertex))
        self.triangles.append(indexes)

    def add_geometries(self, feature_list):
        &#34;&#34;&#34;
        Add 3D features to the OBJ.
        :param feature_list: a FeatureList
        &#34;&#34;&#34;
        for geometry in feature_list:
            self.add_to_centroid(geometry.get_centroid())
            for triangle in geometry.get_geom_as_triangles():
                self.add_triangle(triangle)

    def write_obj(self, file_name):
        &#34;&#34;&#34;
        Write the OBJ into a file.
        :param file_name: the name of the OBJ file
        &#34;&#34;&#34;
        centroid = self.get_centroid()
        Path(file_name).parent.mkdir(parents=True, exist_ok=True)
        f = open(file_name, &#34;w&#34;)
        f.write(&#34;# &#34; + str(file_name) + &#34;\n&#34;)

        for vertex in self.vertices:
            f.write(&#34;v &#34; + str(vertex[0] - centroid[0]) + &#34; &#34; + str(vertex[1] - centroid[1]) + &#34; &#34; + str(vertex[2] - centroid[2]) + &#34;\n&#34;)

        for triangle in self.triangles:
            f.write(&#34;f &#34; + str(int(triangle[0])) + &#34; &#34; + str(int(triangle[1])) + &#34; &#34; + str(int(triangle[2])) + &#34;\n&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.ObjWriter.add_geometries"><code class="name flex">
<span>def <span class="ident">add_geometries</span></span>(<span>self, feature_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Add 3D features to the OBJ.
:param feature_list: a FeatureList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geometries(self, feature_list):
    &#34;&#34;&#34;
    Add 3D features to the OBJ.
    :param feature_list: a FeatureList
    &#34;&#34;&#34;
    for geometry in feature_list:
        self.add_to_centroid(geometry.get_centroid())
        for triangle in geometry.get_geom_as_triangles():
            self.add_triangle(triangle)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.add_to_centroid"><code class="name flex">
<span>def <span class="ident">add_to_centroid</span></span>(<span>self, geom_centroid)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the centroid of a geometry to the centroid of the OBJ.
:param geom_centroid: the centroid of the geometry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_centroid(self, geom_centroid):
    &#34;&#34;&#34;
    Add the centroid of a geometry to the centroid of the OBJ.
    :param geom_centroid: the centroid of the geometry
    &#34;&#34;&#34;
    self.nb_geometries += 1
    for i, coord in enumerate(geom_centroid):
        self.centroid[i] += coord</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.add_triangle"><code class="name flex">
<span>def <span class="ident">add_triangle</span></span>(<span>self, triangle)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a triangle to the OBJ.
:param triangle: the triangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_triangle(self, triangle):
    &#34;&#34;&#34;
    Add a triangle to the OBJ.
    :param triangle: the triangle
    &#34;&#34;&#34;
    indexes = list()
    for vertex in triangle:
        indexes.append(self.get_vertex_index(vertex))
    self.triangles.append(indexes)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.get_centroid"><code class="name flex">
<span>def <span class="ident">get_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and return the normalized centroid of the OBJ.
:return: the centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroid(self):
    &#34;&#34;&#34;
    Compute and return the normalized centroid of the OBJ.
    :return: the centroid
    &#34;&#34;&#34;
    self.centroid[:] = [c / self.nb_geometries for c in self.centroid]
    return self.centroid</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an index for new vertex.
:return: the index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index(self):
    &#34;&#34;&#34;
    Return an index for new vertex.
    :return: the index
    &#34;&#34;&#34;
    self.index += 1
    return self.index</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.get_vertex_index"><code class="name flex">
<span>def <span class="ident">get_vertex_index</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the index associated to a vertex.
If no index is associated to the vertex, create a new index.
:param vertex: the vertex</p>
<p>:return: the index associated to the vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertex_index(self, vertex):
    &#34;&#34;&#34;
    Return the index associated to a vertex.
    If no index is associated to the vertex, create a new index.
    :param vertex: the vertex

    :return: the index associated to the vertex
    &#34;&#34;&#34;
    vertex = vertex.tolist()
    if not tuple(vertex) in self.vertex_indexes:
        self.vertex_indexes[tuple(vertex)] = self.get_index()
        self.vertices.append(vertex)

    return self.vertex_indexes[tuple(vertex)]</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.ObjWriter.write_obj"><code class="name flex">
<span>def <span class="ident">write_obj</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the OBJ into a file.
:param file_name: the name of the OBJ file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_obj(self, file_name):
    &#34;&#34;&#34;
    Write the OBJ into a file.
    :param file_name: the name of the OBJ file
    &#34;&#34;&#34;
    centroid = self.get_centroid()
    Path(file_name).parent.mkdir(parents=True, exist_ok=True)
    f = open(file_name, &#34;w&#34;)
    f.write(&#34;# &#34; + str(file_name) + &#34;\n&#34;)

    for vertex in self.vertices:
        f.write(&#34;v &#34; + str(vertex[0] - centroid[0]) + &#34; &#34; + str(vertex[1] - centroid[1]) + &#34; &#34; + str(vertex[2] - centroid[2]) + &#34;\n&#34;)

    for triangle in self.triangles:
        f.write(&#34;f &#34; + str(int(triangle[0])) + &#34; &#34; + str(int(triangle[1])) + &#34; &#34; + str(int(triangle[2])) + &#34;\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.Tiler"><code class="flex name class">
<span>class <span class="ident">Tiler</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tiler():

    def __init__(self):
        text = &#39;&#39;&#39;A small utility that build a 3DTiles tileset out of data&#39;&#39;&#39;
        self.parser = argparse.ArgumentParser(description=text)

        self.parser.add_argument(&#39;--obj&#39;,
                                 nargs=&#39;?&#39;,
                                 type=str,
                                 help=&#39;When defined, also create an .obj model of the features.\
                                    The flag must be followed by the name of the obj that will be created.&#39;)

        self.parser.add_argument(&#39;--loa&#39;,
                                 nargs=&#39;?&#39;,
                                 type=str,
                                 help=&#39;Creates a LOA when defined. The LOA is a 3D extrusion of polygons.\
                                    Objects in the same polygon are merged together.\
                                    Must be followed by the path to directory containing the polygons .geojson&#39;)

        self.parser.add_argument(&#39;--lod1&#39;,
                                 dest=&#39;lod1&#39;,
                                 action=&#39;store_true&#39;,
                                 help=&#39;Creates a LOD1 when defined. The LOD1 is a 3D extrusion of the footprint of each object.&#39;)

        self.parser.add_argument(&#39;--offset&#39;,
                                 nargs=&#39;*&#39;,
                                 default=[0, 0, 0],
                                 help=&#39;Substract an offset to all the vertices.&#39;)

        self.parser.add_argument(&#39;--scale&#39;,
                                 nargs=&#39;?&#39;,
                                 type=float,
                                 help=&#39;Scale features by the input factor.&#39;)

        self.parser.add_argument(&#39;--crs_in&#39;,
                                 nargs=&#39;?&#39;,
                                 default=&#39;EPSG:3946&#39;,
                                 type=str,
                                 help=&#39;Input projection.&#39;)

        self.parser.add_argument(&#39;--crs_out&#39;,
                                 nargs=&#39;?&#39;,
                                 default=&#39;EPSG:3946&#39;,
                                 type=str,
                                 help=&#39;Output projection.&#39;)

        self.parser.add_argument(&#39;--with_texture&#39;,
                                 dest=&#39;with_texture&#39;,
                                 action=&#39;store_true&#39;,
                                 help=&#39;Adds texture to 3DTiles when defined&#39;)

        self.parser.add_argument(&#39;--output_dir&#39;,
                                 nargs=&#39;?&#39;,
                                 type=str,
                                 help=&#39;Output directory of the tileset.&#39;)

    def parse_command_line(self):
        self.args = self.parser.parse_args()

        if(self.args.obj is not None and &#39;.obj&#39; not in self.args.obj):
            self.args.obj = self.args.obj + &#39;.obj&#39;

        if(len(self.args.offset) &lt; 3):
            for i in range(len(self.args.offset), 3):
                self.args.offset.append(0)
        elif(len(self.args.offset) &gt; 3):
            self.args.offset = self.args.offset[:3]

    def get_output_dir(self):
        &#34;&#34;&#34;
        Return the directory name for the tileset.
        &#34;&#34;&#34;
        if self.args.output_dir is None:
            return &#34;output_tileset&#34;
        else:
            return self.args.output_dir

    def write_geometries_as_obj(self, features, file_name):
        obj_writer = ObjWriter()
        obj_writer.add_geometries(features.get_features())
        obj_writer.write_obj(file_name)

    def change_projection(self, features, crs_in, crs_out):
        transformer = Transformer.from_crs(crs_in, crs_out)
        features.change_crs(transformer)

    def create_tree(self, feature_list, create_lod1=False, create_loa=False, polygons_path=None, with_texture=False):
        lod_tree = LodTree(feature_list, create_lod1, create_loa, polygons_path, with_texture)
        return lod_tree

    def create_tileset_from_geometries(self, feature_list, extension_name=None):
        create_loa = self.args.loa is not None
        tree = self.create_tree(feature_list, self.args.lod1, create_loa, self.args.loa, self.args.with_texture)

        if hasattr(self.args, &#39;scale&#39;) and self.args.scale:
            for objects in tree.get_all_objects():
                objects.scale_features(self.args.scale)

        if not all(v == 0 for v in self.args.offset) or self.args.offset[0] == &#39;centroid&#39;:
            if self.args.offset[0] == &#39;centroid&#39;:
                self.args.offset = tree.get_centroid()
            for objects in tree.get_all_objects():
                objects.translate_features(self.args.offset)

        if not self.args.crs_in == self.args.crs_out:
            for objects in tree.get_all_objects():
                self.change_projection(objects, self.args.crs_in, self.args.crs_out)

        if self.args.obj is not None:
            self.write_geometries_as_obj(tree.get_leaf_objects(), self.args.obj)

        feature_list.delete_objects_ref()
        self.create_output_directory()
        return FromGeometryTreeToTileset.convert_to_tileset(tree, extension_name)

    def create_output_directory(self):
        dir = self.get_output_dir()
        target_dir = Path(dir).expanduser()
        Path(target_dir).mkdir(parents=True, exist_ok=True)
        target_dir = Path(dir, &#39;tiles&#39;).expanduser()
        Path(target_dir).mkdir(parents=True, exist_ok=True)
        Texture.set_texture_folder(dir)

    def get_color_config(self, config_path):
        return ColorConfig(config_path)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.CityTiler.CityTiler" href="../CityTiler/CityTiler.html#py3dtilers.CityTiler.CityTiler.CityTiler">CityTiler</a></li>
<li><a title="py3dtilers.GeojsonTiler.GeojsonTiler.GeojsonTiler" href="../GeojsonTiler/GeojsonTiler.html#py3dtilers.GeojsonTiler.GeojsonTiler.GeojsonTiler">GeojsonTiler</a></li>
<li><a title="py3dtilers.IfcTiler.IfcTiler.IfcTiler" href="../IfcTiler/IfcTiler.html#py3dtilers.IfcTiler.IfcTiler.IfcTiler">IfcTiler</a></li>
<li><a title="py3dtilers.ObjTiler.ObjTiler.ObjTiler" href="../ObjTiler/ObjTiler.html#py3dtilers.ObjTiler.ObjTiler.ObjTiler">ObjTiler</a></li>
<li><a title="py3dtilers.TilesetReader.TilesetReader.TilesetTiler" href="../TilesetReader/TilesetReader.html#py3dtilers.TilesetReader.TilesetReader.TilesetTiler">TilesetTiler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.Tiler.change_projection"><code class="name flex">
<span>def <span class="ident">change_projection</span></span>(<span>self, features, crs_in, crs_out)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_projection(self, features, crs_in, crs_out):
    transformer = Transformer.from_crs(crs_in, crs_out)
    features.change_crs(transformer)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.create_output_directory"><code class="name flex">
<span>def <span class="ident">create_output_directory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_output_directory(self):
    dir = self.get_output_dir()
    target_dir = Path(dir).expanduser()
    Path(target_dir).mkdir(parents=True, exist_ok=True)
    target_dir = Path(dir, &#39;tiles&#39;).expanduser()
    Path(target_dir).mkdir(parents=True, exist_ok=True)
    Texture.set_texture_folder(dir)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.create_tileset_from_geometries"><code class="name flex">
<span>def <span class="ident">create_tileset_from_geometries</span></span>(<span>self, feature_list, extension_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tileset_from_geometries(self, feature_list, extension_name=None):
    create_loa = self.args.loa is not None
    tree = self.create_tree(feature_list, self.args.lod1, create_loa, self.args.loa, self.args.with_texture)

    if hasattr(self.args, &#39;scale&#39;) and self.args.scale:
        for objects in tree.get_all_objects():
            objects.scale_features(self.args.scale)

    if not all(v == 0 for v in self.args.offset) or self.args.offset[0] == &#39;centroid&#39;:
        if self.args.offset[0] == &#39;centroid&#39;:
            self.args.offset = tree.get_centroid()
        for objects in tree.get_all_objects():
            objects.translate_features(self.args.offset)

    if not self.args.crs_in == self.args.crs_out:
        for objects in tree.get_all_objects():
            self.change_projection(objects, self.args.crs_in, self.args.crs_out)

    if self.args.obj is not None:
        self.write_geometries_as_obj(tree.get_leaf_objects(), self.args.obj)

    feature_list.delete_objects_ref()
    self.create_output_directory()
    return FromGeometryTreeToTileset.convert_to_tileset(tree, extension_name)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.create_tree"><code class="name flex">
<span>def <span class="ident">create_tree</span></span>(<span>self, feature_list, create_lod1=False, create_loa=False, polygons_path=None, with_texture=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tree(self, feature_list, create_lod1=False, create_loa=False, polygons_path=None, with_texture=False):
    lod_tree = LodTree(feature_list, create_lod1, create_loa, polygons_path, with_texture)
    return lod_tree</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.get_color_config"><code class="name flex">
<span>def <span class="ident">get_color_config</span></span>(<span>self, config_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_color_config(self, config_path):
    return ColorConfig(config_path)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.get_output_dir"><code class="name flex">
<span>def <span class="ident">get_output_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the directory name for the tileset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_dir(self):
    &#34;&#34;&#34;
    Return the directory name for the tileset.
    &#34;&#34;&#34;
    if self.args.output_dir is None:
        return &#34;output_tileset&#34;
    else:
        return self.args.output_dir</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.parse_command_line"><code class="name flex">
<span>def <span class="ident">parse_command_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_command_line(self):
    self.args = self.parser.parse_args()

    if(self.args.obj is not None and &#39;.obj&#39; not in self.args.obj):
        self.args.obj = self.args.obj + &#39;.obj&#39;

    if(len(self.args.offset) &lt; 3):
        for i in range(len(self.args.offset), 3):
            self.args.offset.append(0)
    elif(len(self.args.offset) &gt; 3):
        self.args.offset = self.args.offset[:3]</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.Tiler.write_geometries_as_obj"><code class="name flex">
<span>def <span class="ident">write_geometries_as_obj</span></span>(<span>self, features, file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_geometries_as_obj(self, features, file_name):
    obj_writer = ObjWriter()
    obj_writer.add_geometries(features.get_features())
    obj_writer.write_obj(file_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.TreeWithChildrenAndParent"><code class="flex name class">
<span>class <span class="ident">TreeWithChildrenAndParent</span></span>
</code></dt>
<dd>
<div class="desc"><p>A simple hierarchy/Direct Acyclic Graph, as in
<a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">https://en.wikipedia.org/wiki/Tree_%28data_structure%29</a>) with both
children and parent relationships explicitly represented (for the
sake of retrieval efficiency) as dictionaries using some user
defined identifier as keys. TreeWithChildrenAndParent is not
responsible of the identifiers and simply uses them as provided
weak references.</p>
<p>Children of a given id (given as dict key)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TreeWithChildrenAndParent:
    &#34;&#34;&#34;
    A simple hierarchy/Direct Acyclic Graph, as in
    https://en.wikipedia.org/wiki/Tree_%28data_structure%29) with both
    children and parent relationships explicitly represented (for the
    sake of retrieval efficiency) as dictionaries using some user
    defined identifier as keys. TreeWithChildrenAndParent is not
    responsible of the identifiers and simply uses them as provided
    weak references.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Children of a given id (given as dict key)&#34;&#34;&#34;
        self.hierarchy = {}
        &#34;&#34;&#34;Parents of a given id (given as dict key)&#34;&#34;&#34;
        self.reverseHierarchy = {}

    def addNodeToParent(self, object_id, parent_id):
        if parent_id is not None:
            if parent_id not in self.hierarchy:
                self.hierarchy[parent_id] = []
            self.hierarchy[parent_id].append(object_id)
            self.reverseHierarchy[object_id] = parent_id

    def getParents(self, object_id):
        if object_id in self.reverseHierarchy:
            return [self.reverseHierarchy[object_id]]
        return []</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="py3dtilers.Common.TreeWithChildrenAndParent.hierarchy"><code class="name">var <span class="ident">hierarchy</span></code></dt>
<dd>
<div class="desc"><p>Parents of a given id (given as dict key)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.TreeWithChildrenAndParent.addNodeToParent"><code class="name flex">
<span>def <span class="ident">addNodeToParent</span></span>(<span>self, object_id, parent_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addNodeToParent(self, object_id, parent_id):
    if parent_id is not None:
        if parent_id not in self.hierarchy:
            self.hierarchy[parent_id] = []
        self.hierarchy[parent_id].append(object_id)
        self.reverseHierarchy[object_id] = parent_id</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.TreeWithChildrenAndParent.getParents"><code class="name flex">
<span>def <span class="ident">getParents</span></span>(<span>self, object_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getParents(self, object_id):
    if object_id in self.reverseHierarchy:
        return [self.reverseHierarchy[object_id]]
    return []</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers" href="../index.html">py3dtilers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="py3dtilers.Common.feature" href="feature.html">py3dtilers.Common.feature</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_node" href="geometry_node.html">py3dtilers.Common.geometry_node</a></code></li>
<li><code><a title="py3dtilers.Common.geometry_tree" href="geometry_tree.html">py3dtilers.Common.geometry_tree</a></code></li>
<li><code><a title="py3dtilers.Common.group" href="group.html">py3dtilers.Common.group</a></code></li>
<li><code><a title="py3dtilers.Common.lod_node" href="lod_node.html">py3dtilers.Common.lod_node</a></code></li>
<li><code><a title="py3dtilers.Common.lod_tree" href="lod_tree.html">py3dtilers.Common.lod_tree</a></code></li>
<li><code><a title="py3dtilers.Common.obj_writer" href="obj_writer.html">py3dtilers.Common.obj_writer</a></code></li>
<li><code><a title="py3dtilers.Common.polygon_extrusion" href="polygon_extrusion.html">py3dtilers.Common.polygon_extrusion</a></code></li>
<li><code><a title="py3dtilers.Common.tiler" href="tiler.html">py3dtilers.Common.tiler</a></code></li>
<li><code><a title="py3dtilers.Common.tileset_creation" href="tileset_creation.html">py3dtilers.Common.tileset_creation</a></code></li>
<li><code><a title="py3dtilers.Common.tree_with_children_and_parent" href="tree_with_children_and_parent.html">py3dtilers.Common.tree_with_children_and_parent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="py3dtilers.Common.kd_tree" href="#py3dtilers.Common.kd_tree">kd_tree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.Common.ExtrudedPolygon" href="#py3dtilers.Common.ExtrudedPolygon">ExtrudedPolygon</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.ExtrudedPolygon.extrude_footprint" href="#py3dtilers.Common.ExtrudedPolygon.extrude_footprint">extrude_footprint</a></code></li>
<li><code><a title="py3dtilers.Common.ExtrudedPolygon.get_extruded_object" href="#py3dtilers.Common.ExtrudedPolygon.get_extruded_object">get_extruded_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.Feature" href="#py3dtilers.Common.Feature">Feature</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.Feature.get_batchtable_data" href="#py3dtilers.Common.Feature.get_batchtable_data">get_batchtable_data</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.get_bounding_volume_box" href="#py3dtilers.Common.Feature.get_bounding_volume_box">get_bounding_volume_box</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.get_centroid" href="#py3dtilers.Common.Feature.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.get_geom_as_triangles" href="#py3dtilers.Common.Feature.get_geom_as_triangles">get_geom_as_triangles</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.get_id" href="#py3dtilers.Common.Feature.get_id">get_id</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.get_texture" href="#py3dtilers.Common.Feature.get_texture">get_texture</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.has_texture" href="#py3dtilers.Common.Feature.has_texture">has_texture</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.set_batchtable_data" href="#py3dtilers.Common.Feature.set_batchtable_data">set_batchtable_data</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.set_box" href="#py3dtilers.Common.Feature.set_box">set_box</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.set_id" href="#py3dtilers.Common.Feature.set_id">set_id</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.set_texture" href="#py3dtilers.Common.Feature.set_texture">set_texture</a></code></li>
<li><code><a title="py3dtilers.Common.Feature.set_triangles" href="#py3dtilers.Common.Feature.set_triangles">set_triangles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.FeatureList" href="#py3dtilers.Common.FeatureList">FeatureList</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.FeatureList.add_materials" href="#py3dtilers.Common.FeatureList.add_materials">add_materials</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.append" href="#py3dtilers.Common.FeatureList.append">append</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.change_crs" href="#py3dtilers.Common.FeatureList.change_crs">change_crs</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.create_batch_table_extension" href="#py3dtilers.Common.FeatureList.create_batch_table_extension">create_batch_table_extension</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.create_bounding_volume_extension" href="#py3dtilers.Common.FeatureList.create_bounding_volume_extension">create_bounding_volume_extension</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.default_mat" href="#py3dtilers.Common.FeatureList.default_mat">default_mat</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.delete_objects_ref" href="#py3dtilers.Common.FeatureList.delete_objects_ref">delete_objects_ref</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.extend" href="#py3dtilers.Common.FeatureList.extend">extend</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.get_centroid" href="#py3dtilers.Common.FeatureList.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.get_features" href="#py3dtilers.Common.FeatureList.get_features">get_features</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.get_material" href="#py3dtilers.Common.FeatureList.get_material">get_material</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.get_textures" href="#py3dtilers.Common.FeatureList.get_textures">get_textures</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.is_list_of_feature_list" href="#py3dtilers.Common.FeatureList.is_list_of_feature_list">is_list_of_feature_list</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.scale_features" href="#py3dtilers.Common.FeatureList.scale_features">scale_features</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.set_materials" href="#py3dtilers.Common.FeatureList.set_materials">set_materials</a></code></li>
<li><code><a title="py3dtilers.Common.FeatureList.translate_features" href="#py3dtilers.Common.FeatureList.translate_features">translate_features</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.FromGeometryTreeToTileset" href="#py3dtilers.Common.FromGeometryTreeToTileset">FromGeometryTreeToTileset</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.FromGeometryTreeToTileset.convert_to_tileset" href="#py3dtilers.Common.FromGeometryTreeToTileset.convert_to_tileset">convert_to_tileset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.GeometryNode" href="#py3dtilers.Common.GeometryNode">GeometryNode</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.GeometryNode.add_child_node" href="#py3dtilers.Common.GeometryNode.add_child_node">add_child_node</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryNode.geometries_have_texture" href="#py3dtilers.Common.GeometryNode.geometries_have_texture">geometries_have_texture</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryNode.get_features" href="#py3dtilers.Common.GeometryNode.get_features">get_features</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryNode.get_leaves" href="#py3dtilers.Common.GeometryNode.get_leaves">get_leaves</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryNode.has_texture" href="#py3dtilers.Common.GeometryNode.has_texture">has_texture</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryNode.set_child_nodes" href="#py3dtilers.Common.GeometryNode.set_child_nodes">set_child_nodes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.GeometryTree" href="#py3dtilers.Common.GeometryTree">GeometryTree</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.GeometryTree.get_all_objects" href="#py3dtilers.Common.GeometryTree.get_all_objects">get_all_objects</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryTree.get_centroid" href="#py3dtilers.Common.GeometryTree.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryTree.get_leaf_nodes" href="#py3dtilers.Common.GeometryTree.get_leaf_nodes">get_leaf_nodes</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryTree.get_leaf_objects" href="#py3dtilers.Common.GeometryTree.get_leaf_objects">get_leaf_objects</a></code></li>
<li><code><a title="py3dtilers.Common.GeometryTree.get_root_objects" href="#py3dtilers.Common.GeometryTree.get_root_objects">get_root_objects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.Groups" href="#py3dtilers.Common.Groups">Groups</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.Groups.distribute_groups_in_cubes" href="#py3dtilers.Common.Groups.distribute_groups_in_cubes">distribute_groups_in_cubes</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.distribute_objects_in_polygons" href="#py3dtilers.Common.Groups.distribute_objects_in_polygons">distribute_objects_in_polygons</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.get_groups_as_list" href="#py3dtilers.Common.Groups.get_groups_as_list">get_groups_as_list</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.group_objects_by_instance" href="#py3dtilers.Common.Groups.group_objects_by_instance">group_objects_by_instance</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.group_objects_by_polygons" href="#py3dtilers.Common.Groups.group_objects_by_polygons">group_objects_by_polygons</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.group_objects_with_kdtree" href="#py3dtilers.Common.Groups.group_objects_with_kdtree">group_objects_with_kdtree</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.merge_groups_together" href="#py3dtilers.Common.Groups.merge_groups_together">merge_groups_together</a></code></li>
<li><code><a title="py3dtilers.Common.Groups.set_materials" href="#py3dtilers.Common.Groups.set_materials">set_materials</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.LoaNode" href="#py3dtilers.Common.LoaNode">LoaNode</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.LoaNode.create_loa_from_polygon" href="#py3dtilers.Common.LoaNode.create_loa_from_polygon">create_loa_from_polygon</a></code></li>
<li><code><a title="py3dtilers.Common.LoaNode.loa_index" href="#py3dtilers.Common.LoaNode.loa_index">loa_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.Lod1Node" href="#py3dtilers.Common.Lod1Node">Lod1Node</a></code></h4>
</li>
<li>
<h4><code><a title="py3dtilers.Common.LodTree" href="#py3dtilers.Common.LodTree">LodTree</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.LodTree.group_features" href="#py3dtilers.Common.LodTree.group_features">group_features</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.ObjWriter" href="#py3dtilers.Common.ObjWriter">ObjWriter</a></code></h4>
<ul class="two-column">
<li><code><a title="py3dtilers.Common.ObjWriter.add_geometries" href="#py3dtilers.Common.ObjWriter.add_geometries">add_geometries</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.add_to_centroid" href="#py3dtilers.Common.ObjWriter.add_to_centroid">add_to_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.add_triangle" href="#py3dtilers.Common.ObjWriter.add_triangle">add_triangle</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.get_centroid" href="#py3dtilers.Common.ObjWriter.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.get_index" href="#py3dtilers.Common.ObjWriter.get_index">get_index</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.get_vertex_index" href="#py3dtilers.Common.ObjWriter.get_vertex_index">get_vertex_index</a></code></li>
<li><code><a title="py3dtilers.Common.ObjWriter.write_obj" href="#py3dtilers.Common.ObjWriter.write_obj">write_obj</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.Tiler" href="#py3dtilers.Common.Tiler">Tiler</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.Tiler.change_projection" href="#py3dtilers.Common.Tiler.change_projection">change_projection</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.create_output_directory" href="#py3dtilers.Common.Tiler.create_output_directory">create_output_directory</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.create_tileset_from_geometries" href="#py3dtilers.Common.Tiler.create_tileset_from_geometries">create_tileset_from_geometries</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.create_tree" href="#py3dtilers.Common.Tiler.create_tree">create_tree</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.get_color_config" href="#py3dtilers.Common.Tiler.get_color_config">get_color_config</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.get_output_dir" href="#py3dtilers.Common.Tiler.get_output_dir">get_output_dir</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.parse_command_line" href="#py3dtilers.Common.Tiler.parse_command_line">parse_command_line</a></code></li>
<li><code><a title="py3dtilers.Common.Tiler.write_geometries_as_obj" href="#py3dtilers.Common.Tiler.write_geometries_as_obj">write_geometries_as_obj</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.TreeWithChildrenAndParent" href="#py3dtilers.Common.TreeWithChildrenAndParent">TreeWithChildrenAndParent</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.TreeWithChildrenAndParent.addNodeToParent" href="#py3dtilers.Common.TreeWithChildrenAndParent.addNodeToParent">addNodeToParent</a></code></li>
<li><code><a title="py3dtilers.Common.TreeWithChildrenAndParent.getParents" href="#py3dtilers.Common.TreeWithChildrenAndParent.getParents">getParents</a></code></li>
<li><code><a title="py3dtilers.Common.TreeWithChildrenAndParent.hierarchy" href="#py3dtilers.Common.TreeWithChildrenAndParent.hierarchy">hierarchy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>